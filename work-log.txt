----------------------------------------------------
NOTES TO KEEP TRACK OF PROGRESS, IDEAS, PROBLEMS EG.
----------------------------------------------------

--- 1/23/17 ---
Matildha:
Created git repo. Copied fhresh pintos files into it and commited, 
none of my previous changes to lab1 added yet. 
  Made all the tests in lab0 and added commands to .bashrc. Unsure if it works 
properly though. Added the tags to emacs and ran the alarm-single with and without gdb.
  
TODO: Try to understand what changes I made to lab1 and then transfer them into new 
project if seems correct. !DONE!

--- 1/27/17 ---
Matildha:
Changed the *esp pointer to PYSBASE - 12 and set process_wait() to infinite loop. 
   Much of what I did previously in lab1 seem to be kinda of wrong... 

--- 1/31/17 ---
Matildha:
Copied old halt() function to present. 
   
TODO: Should all syscall functions be declared static? 

--- 2/1/17 ---
Matildha:
Create file function seems to work. Does not test arguments. 
   Found useful read and write operations in file.c. (good filename lol)

Added nr_open_files to 'struct thread' and pointer to dynamically allocated array for file descriptor table - which consists of 'struct file*' pointers. Failed to allocate array in thread_init() since #ifdef USERPROG made it unavaiable.
   Wrote something quick in syscall, a function callled init_fd_table that allocates the array and sets nr_open_files to 0. Not finished, not tested. 
TODO: Try to initialize fd_table and nr_open_files in syscall.c. 

--- 2/2/17 ---
Matildha:
You are allowed to put fd_table array i thread struct. Set all elements to NULL in thread_init. 
  Succeeded to open a file and put it at the first position in the fd_table. Added max_nr_open_files in thread struct. 
TODO: Should this be constant? HOW?
TODO: Fix get_new_fd() to handle several open calls.

--- 2/3/17 ---
Matildha & Dominique:
We have done the write and close functions, the write function is tested and seems to work. We moved initialasion of thread struct variables to init_thread instead of thread_init. 

--- 2/7/17 --- 
Matildha & Dominique:
Done write and read functions, works both from files and from console. Haven't confirmed that read works from keyboard. 
TODO: Unsure what/how to test?
  Close seems to work, at least for a single open file. 

PROBLEM: Can't have 2 open files at the same time. First open call fails if there is a second open call afterwards. Close in between don't matter. 

-- 2/7/17 ---
Matildha:
Wrote skeleton for switch statement in syscall handler. Created a custom test in examples. Is going to test create which is the only case with function call in handler.
TODO: Fix compilation errors and test the create syscall. (Does retreiving of arguments work as I've written it nowb?)

--- 2/8/17 ---
Matildha:
Finished switch statement with call to all out functions. Created a function get_args() which puts the right number of arguments into an array allocated in syscall_handler. Create, write and open and exit seems to work. Not tested halt yet. 
   I thiiiink the problem with opening 2 files did not appear to be a problem when running lab1test. 
PROBLEM: Read from console deos however NOT work with lab1test. I can't currently rule out that it's because of the ssh x11 connection i used in doing the test. 
TODO: Test lab1test from school pc.  

--- 2/9/17 ---
Dominique & Matildha:
Passed the lab1test. Fixed the problems when reading on the console. Adding the validate_fd function into several other functions. Closed the files that the user did not close in exit(). 

--- 13/2/17 ---
Matildha:

STARTING LAB 2:

thread_block() puts thread to sleep, used through synch module primitives. 

Use list_insert_ordered() ? - impossible when using semaphores. They called push-back and pop_front directly. 

--- 14/2/17 ---
Matildha & Dominique: 
Created the sleep_queue and sleep_sema inside thread.c. And a list in timer.c to hold structs which keep track of time of ticks a certain process wants to sleep and the starting time for the sleep. Items in this list should be inserted with list_insert_ordered. 

TODO: Create the comparator function for the insert_ordered. Add code in timer_interrupt(). 
TODO: list_entry?????? 

--- 14/2/17 ---
Matildha: 
Free p_sleep_time struct after sema_down in timer_sleep(). Free the same struct right after. 

We will probably need a local semaphore for management of the  tick_list!! 

I DO BELIEVE our tick_list is our ACTUAL SLEEP_QUEUE!!!!!!!!!!!!!! 

timer_ticks() protects ticks variable by disabling and reenabling interrupts... NOT using any lock or semaphore?? Would we be allowed to do this as well? 
  - Yes, inside timer_interrupt() right? Cuz we can't call sema_down inside an interrupt handler!? 

-- 15/2/17 ---
Matildha and Dominique 
Finish the timer_interrupt function. Fix several compilations errors left from passed sessions. We followed the teacher's recommendation regarding lab 1. 
TODO : protect tick_list. create small test? otherwise start real tests. 












